Get interpreter working.

Add a debugger to the interpreter. At each instruction entry, have D. 
This can call the debugging function with the current WState and
RState. The WState can include all debugging information. Also have
D_Init and D_Finalise, which can provide the rest. Actually write the
debugger in a separate file, which is #included if debugging turned
on.

Change reader and writer files so that they have foo = ... for each
field, rather than just listing the fields. Use the new standard
library stuff for this. Might also want to construct a util.lua to
avoid relying on my std lib.

Rather than having a resolve flag, have a resolve string containing
the macros & functions needed for resolution, and don't generate the
resolution function if it's empty.


Use a better build tool: cook or cons (?). Rewrite scripts in OCaml
for better definition of the type of a reader and writer, and easier
debugging in future (plus more people know OCaml than Lua!).

Make a distribution that can easily be compiled with any ANSI C
compiler.

Write a Lua script to process LaTeX files semi-intelligently, i.e. 
search for "bibliography" and if not found, just run latex twice;
otherwise, run latex, bibtex, latex, latex. Look in l2web.

Make a file bundle release (just a tar of the contents of CVS).

Check out & build Mite on a clean system.

Reduce the number of warnings given by gcc.


Check whether shifts of type size are allowed, and stop using them if
not.


Test system:

Have a Lua script which takes a file of the form:

test = {
  input = "<input>",
  input_type = "<in-type>",
  output_type = "<out-type>",
  flags = "<flags-to-mit>",
  output = { <list-of-outputs> }
}

and runs

  mit <flags to mit> -.<in type> -.<out type> 2>1

The output is piped back in and compared against each output in the
test table, which can be either genuine output or an error. If one
matches, the test passes; otherwise it fails.

Have another script that takes an input file, input type, output type
and flags, and produces a test file from it.


Extensions:

Accessing dynamic libs: return the address of the given symbol; should
work at least for the standard C library.

FP instruction set (using new reg set, use only 64-bit IEEE numbers).

Higher level calling: use SWIG or libffi

Safe memory access (just ld/st): to do this, only allow addresses in
range of static data area or areas returned by special malloc function
(which can just be a wrapper for malloc, or for greater efficiency,
malloc recompiled to allocate in an area provided by mit).


Separate compilation of Mite code

Use a custom format, and dynamic linking.

Allow dynamic linking? Mite code could be DLed to native code. Would
need to distinguish Mite symbols from native ones. Review work on
dynamic loading in Lua to find a good method.

Mite starts by loading a single object file. All other facilities can
be provided in virtual code; just need to add access to libffi/Swig. 
Allow Mite modules to be loaded and linked in. Preferably possible to
load just code (no symbols) if desired. Need export/import labels for
Mite and native symbols.

Addresses can only be known after word-length independence adjustment.


Good magic value for 7-coded stream: 37F06EDh (becomes 1B7C0DEDh when
7-coded).
